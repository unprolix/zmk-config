#!/usr/bin/env python3
"""
ZMK Auto Flash Script
Automatically flashes firmware to configured devices that are currently in bootloader mode.
Reads device configuration from ~/.config/zmk/devices.yaml and uses detection logic from flash.sh.
"""

import os
import re
import subprocess
import sys
import time
import glob
from pathlib import Path


def load_device_config():
    """Load device configuration from ~/.config/zmk/devices.yaml or devices.conf"""
    config_dir = Path.home() / ".config" / "zmk"
    yaml_path = config_dir / "devices.yaml"
    conf_path = config_dir / "devices.conf"
    devices = {}
    
    # Try YAML format first
    if yaml_path.exists():
        try:
            import yaml
            with open(yaml_path, 'r') as f:
                config = yaml.safe_load(f)
                if config:
                    for serial, device_info in config.items():
                        # Preserve all existing keys, not just name/type/notes
                        devices[serial] = dict(device_info)
                        # Ensure standard keys exist with defaults
                        devices[serial].setdefault('name', '')
                        devices[serial].setdefault('type', 'unknown')
                        devices[serial].setdefault('notes', '')
            return devices
        except ImportError:
            print("PyYAML not found, falling back to conf format")
        except Exception as e:
            print(f"Error reading YAML config: {e}, falling back to conf format")
    
    # Fall back to conf format
    if conf_path.exists():
        with open(conf_path, 'r') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                
                parts = line.split(':', 3)
                if len(parts) < 2:
                    print(f"Warning: Invalid format at line {line_num}: {line}")
                    continue
                
                serial = parts[0]
                friendly_name = parts[1]
                device_type = parts[2] if len(parts) > 2 else "unknown"
                notes = parts[3] if len(parts) > 3 else ""
                
                devices[serial] = {
                    'name': friendly_name,
                    'type': device_type,
                    'notes': notes
                }
        return devices
    
    print("No config file found. Create ~/.config/zmk/devices.yaml or ~/.config/zmk/devices.conf")
    return devices


def get_usb_devices():
    """Get USB device information using lsusb -v"""
    try:
        result = subprocess.run(['lsusb', '-v'], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
        return result.stdout
    except FileNotFoundError:
        print("Error: lsusb command not found")
        return ""


def parse_usb_devices(lsusb_output):
    """Parse lsusb output to extract device information"""
    devices = []
    current_device = {}
    
    for line in lsusb_output.split('\n'):
        line = line.strip()
        
        if line.startswith('Bus ') and 'Device ' in line:
            if current_device:
                devices.append(current_device)
            current_device = {}
            # Extract bus and device numbers
            match = re.search(r'Bus (\d+) Device (\d+)', line)
            if match:
                current_device['bus'] = match.group(1).zfill(3)
                current_device['device'] = match.group(2).zfill(3)
        
        elif line.startswith('idVendor'):
            match = re.search(r'idVendor\s+0x([0-9a-f]+)\s*(.*)', line)
            if match:
                current_device['vendor_id'] = match.group(1)
                current_device['vendor_name'] = match.group(2).strip()
        
        elif line.startswith('idProduct'):
            match = re.search(r'idProduct\s+0x([0-9a-f]+)\s*(.*)', line)
            if match:
                current_device['product_id'] = match.group(1)
                current_device['product_name'] = match.group(2).strip()
        
        elif line.startswith('iSerial'):
            match = re.search(r'iSerial\s+\d+\s+(.+)', line)
            if match:
                current_device['serial'] = match.group(1).strip()
    
    if current_device:
        devices.append(current_device)
    
    return devices


def determine_firmware_variant(device_name, device_side):
    """
    Determine which firmware variant to use based on device name.
    Maps device names to their corresponding firmware files.
    """
    name_lower = device_name.lower()
    
    # Map device names to firmware variants
    variant_map = {
        'bureau': 'bureau',    # Bureau -> bureau variant
        'salon': 'salon',      # Salon -> salon variant  
        'lavendre': 'lavendre', # Lavendre -> lavendre variant
        'lavendre': 'lavendre', # Lavendre -> lavendre variant
    }
    
    # Find matching variant
    for key, variant in variant_map.items():
        if key in name_lower:
            return variant
    
    # Default to base variant (no suffix)
    return None


def find_firmware_file(device_name, device_side, firmware_dir):
    """
    Find the appropriate firmware file for a device.
    Based on the logic from flash.sh but adapted for our naming scheme.
    """
    variant = determine_firmware_variant(device_name, device_side)
    
    # Build search patterns
    patterns = []
    
    if variant:
        # Try variant-specific firmware first
        if device_side == 'left':
            patterns.append(f"eyelash_corne_left_{variant}-*.uf2")
        elif device_side == 'right':
            patterns.append(f"eyelash_corne_right_{variant}-*.uf2")
        else:
            # Try both sides if side is unknown
            patterns.extend([
                f"eyelash_corne_left_{variant}-*.uf2",
                f"eyelash_corne_right_{variant}-*.uf2"
            ])
    
    # Fallback to base firmware
    if device_side == 'left':
        patterns.append("eyelash_corne_left-*.uf2")
    elif device_side == 'right':
        patterns.append("eyelash_corne_right-*.uf2")
    else:
        patterns.extend([
            "eyelash_corne_left-*.uf2",
            "eyelash_corne_right-*.uf2"
        ])
    
    # Search for firmware files
    for pattern in patterns:
        matches = glob.glob(str(firmware_dir / pattern))
        if matches:
            # Return the most recent file if multiple matches
            return max(matches, key=os.path.getctime)
    
    return None


def detect_bootloader_devices():
    """
    Detect devices currently in bootloader mode.
    Bootloader devices typically show up as USB mass storage devices.
    """
    bootloader_devices = []
    
    # Get USB devices
    lsusb_output = get_usb_devices()
    if not lsusb_output:
        return bootloader_devices
    
    usb_devices = parse_usb_devices(lsusb_output)
    
    # Look for devices that might be in bootloader mode
    # Common bootloader characteristics:
    # - Vendor names like "Adafruit", "Raspberry Pi", or specific controller vendors
    # - Product names containing "CircuitPython", "RPI-RP2", "UF2 Bootloader", etc.
    bootloader_keywords = [
        'circuitpython', 'uf2', 'bootloader', 'rpi-rp2', 'pico',
        'adafruit', 'raspberry pi', 'seeed', 'nice!nano'
    ]
    
    for device in usb_devices:
        vendor_name = device.get('vendor_name', '').lower()
        product_name = device.get('product_name', '').lower()
        
        # Check if device matches bootloader patterns
        is_bootloader = any(keyword in vendor_name or keyword in product_name 
                          for keyword in bootloader_keywords)
        
        if is_bootloader:
            # Add device path information for mounting
            bus = device.get('bus')
            dev_num = device.get('device')
            if bus and dev_num:
                device['usb_path'] = f"/dev/bus/usb/{bus}/{dev_num}"
            bootloader_devices.append(device)
    
    return bootloader_devices


def find_available_mass_storage_devices():
    """
    Find unmounted mass storage devices that could be bootloaders.
    """
    try:
        # Use lsblk to find removable block devices
        result = subprocess.run(['lsblk', '-rno', 'NAME,TYPE,MOUNTPOINT,LABEL'], 
                              stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
        
        devices = []
        for line in result.stdout.strip().split('\n'):
            if not line:
                continue
            parts = line.split(None, 3)
            if len(parts) >= 3:
                name, device_type, mountpoint = parts[0], parts[1], parts[2]
                label = parts[3] if len(parts) > 3 else ""
                
                
                # Look for disk devices that are not mounted
                # Note: when there's no mount point, lsblk puts the label in the mountpoint field
                is_unmounted = (mountpoint == "" or 
                              (not mountpoint.startswith('/') and not mountpoint.startswith('[')))
                
                if (device_type == 'disk' and is_unmounted):
                    # Skip obvious system disks and swap
                    if (name.startswith('nvme') or 
                        name in ['sda', 'zram0'] or
                        'SWAP' in str(label) or
                        'luks-' in name):
                        continue
                    device_path = f"/dev/{name}"
                    devices.append({
                        'name': name,
                        'path': device_path,
                        'label': label,
                        'type': device_type
                    })
        
        return devices
        
    except FileNotFoundError:
        print("Warning: lsblk not found, cannot detect unmounted devices")
        return []


def find_bootloader_mount_points():
    """
    Find mounted bootloader devices by looking for UF2-compatible mount points.
    """
    mount_points = []
    
    # Common mount point locations
    search_paths = [
        "/media/*/",
        "/mnt/*/", 
        "/Volumes/*/",  # macOS
        "/run/media/*/*/",  # Some Linux distros
    ]
    
    bootloader_indicators = [
        "INFO_UF2.TXT",
        "INDEX.HTM",
        "CURRENT.UF2"
    ]
    
    for search_path in search_paths:
        for mount_point in glob.glob(search_path):
            if os.path.isdir(mount_point):
                # Check if this looks like a bootloader mount
                for indicator in bootloader_indicators:
                    if os.path.exists(os.path.join(mount_point, indicator)):
                        mount_points.append(mount_point.rstrip('/'))
                        break
    
    return mount_points


def get_bootloader_info(mount_point):
    """
    Extract information about the bootloader from INFO_UF2.TXT if available.
    """
    info_file = os.path.join(mount_point, "INFO_UF2.TXT")
    if not os.path.exists(info_file):
        return {}
    
    info = {}
    try:
        with open(info_file, 'r') as f:
            for line in f:
                if ':' in line:
                    key, value = line.strip().split(':', 1)
                    info[key.strip()] = value.strip()
    except Exception:
        pass
    
    return info


def match_bootloader_to_config(bootloader_device, bootloader_info, known_devices):
    """
    Try to match a bootloader device to a configured device.
    This is tricky because bootloader mode may not expose the same serial number.
    """
    # If we have a serial number, try direct match first
    serial = bootloader_device.get('serial')
    if serial and serial in known_devices:
        return known_devices[serial]
    
    # Try to match based on bootloader info
    board_id = bootloader_info.get('Board-ID')
    model = bootloader_info.get('Model')
    
    # For now, we'll have to ask the user or make educated guesses
    # In a real implementation, you might maintain a separate mapping
    # of bootloader identifiers to device configs
    
    return None


def flash_device(mount_point, firmware_file, device_name=None):
    """
    Flash firmware to a bootloader device.
    """
    if not os.path.exists(firmware_file):
        print(f"❌ Firmware file not found: {firmware_file}")
        return False
    
    target_file = os.path.join(mount_point, "CURRENT.UF2")
    
    try:
        print(f"📦 Flashing {os.path.basename(firmware_file)} to {mount_point}")
        
        # Copy firmware file
        import shutil
        shutil.copy2(firmware_file, target_file)
        
        # Sync to ensure write completes
        os.sync()
        
        print(f"✅ Successfully flashed {device_name or 'device'}")
        return True
        
    except Exception as e:
        print(f"❌ Failed to flash {device_name or 'device'}: {e}")
        return False


def mount_device(device_path, mount_point):
    """
    Mount a device to a mount point.
    """
    try:
        # Create mount point if it doesn't exist
        os.makedirs(mount_point, exist_ok=True)
        
        # Mount the device with proper permissions for flashing
        result = subprocess.run(['sudo', 'mount', '-o', 'rw,uid=1000,gid=1000', device_path, mount_point], 
                              capture_output=True, text=True)
        
        if result.returncode == 0:
            return True
        else:
            print(f"Failed to mount {device_path}: {result.stderr}")
            return False
            
    except Exception as e:
        print(f"Error mounting {device_path}: {e}")
        return False


def unmount_device(mount_point):
    """
    Unmount a device.
    """
    try:
        result = subprocess.run(['sudo', 'umount', mount_point], 
                              capture_output=True, text=True)
        return result.returncode == 0
    except Exception:
        return False


def scan_for_bootloaders(known_devices, firmware_dir, require_confirmation=False, scan_duration=5):
    """
    Continuously scan for bootloader devices for the specified duration.
    Returns list of (mount_point, device_config, firmware_file) tuples.
    """
    start_time = time.time()
    scan_interval = 0.5  # Check every 500ms
    found_devices = set()  # Track already-found devices to avoid duplicates
    
    print(f"Scanning for bootloader devices for {scan_duration} seconds...")
    
    while time.time() - start_time < scan_duration:
        flashable = find_flashable_devices_once(known_devices, firmware_dir, require_confirmation, found_devices)
        
        if flashable:
            # Found devices, return immediately
            return flashable
        
        # Wait before next scan
        time.sleep(scan_interval)
    
    print("Scan complete. No devices found.")
    return []


def find_flashable_devices_once(known_devices, firmware_dir, require_confirmation=False, found_devices=None):
    """
    Single scan for devices in bootloader mode that can be flashed.
    Returns list of (mount_point, device_config, firmware_file) tuples.
    """
    if found_devices is None:
        found_devices = set()
        
    flashable = []
    
    # First check for already-mounted bootloader devices
    mount_points = find_bootloader_mount_points()
    mounted_devices = []
    
    if mount_points:
        new_mounted = [mp for mp in mount_points if mp not in found_devices]
        if new_mounted:
            print(f"Found {len(new_mounted)} new mounted bootloader device(s)")
            mounted_devices = new_mounted
            found_devices.update(new_mounted)
    
    # Also check for unmounted bootloader devices
    bootloader_devices = detect_bootloader_devices()
    mass_storage_devices = find_available_mass_storage_devices()
    
    # Try to correlate USB bootloader devices with mass storage devices
    unmounted_devices = []
    for ms_device in mass_storage_devices:
        if ms_device['path'] not in found_devices:
            # This is a simple correlation - in practice you might want more sophisticated matching
            unmounted_devices.append(ms_device)
            found_devices.add(ms_device['path'])
    
    if bootloader_devices:
        new_bootloader_serials = []
        for device in bootloader_devices:
            serial = device.get('serial', device.get('vendor_name', '') + device.get('product_name', ''))
            if serial and serial not in found_devices:
                new_bootloader_serials.append(device)
                found_devices.add(serial)
        
        if new_bootloader_serials:
            print(f"Found {len(new_bootloader_serials)} new USB bootloader device(s)")
            for device in new_bootloader_serials:
                vendor = device.get('vendor_name', 'Unknown')
                product = device.get('product_name', 'Unknown')
                serial = device.get('serial', 'No serial')
                print(f"  - {vendor} {product} (Serial: {serial})")
    
    if unmounted_devices:
        print(f"Found {len(unmounted_devices)} new unmounted mass storage device(s)")
        for device in unmounted_devices:
            print(f"  - {device['path']} (Label: {device['label'] or 'No label'})")
    
    all_devices = []
    
    # Handle already mounted devices
    for mount_point in mounted_devices:
        all_devices.append({
            'type': 'mounted',
            'mount_point': mount_point,
            'device_path': None
        })
    
    # Handle unmounted devices that need mounting
    for device in unmounted_devices:
        all_devices.append({
            'type': 'unmounted', 
            'mount_point': None,
            'device_path': device['path'],
            'label': device.get('label', '')
        })
    
    if not all_devices:
        return flashable
    
    # For each device, try to determine what to flash
    for i, device_info in enumerate(all_devices, 1):
        mount_point = device_info.get('mount_point')
        device_path = device_info.get('device_path')
        needs_unmount = False
        
        # If device is unmounted, we need to mount it temporarily
        if device_info['type'] == 'unmounted':
            temp_mount = f"/tmp/zmk-flash-{i}"
            print(f"\n📱 Unmounted bootloader device: {device_path}")
            print(f"Mounting to {temp_mount} to check device info...")
            
            if mount_device(device_path, temp_mount):
                mount_point = temp_mount
                needs_unmount = True
            else:
                print(f"❌ Failed to mount {device_path}, skipping")
                continue
        
        # Get bootloader info
        bootloader_info = get_bootloader_info(mount_point) if mount_point else {}
        
        # Try to match by serial number from USB device info
        matched_config = None
        usb_serial = None
        
        # Find the USB device with matching serial
        for usb_device in bootloader_devices:
            if usb_device.get('serial'):
                usb_serial = usb_device.get('serial')
                if usb_serial in known_devices:
                    matched_config = known_devices[usb_serial]
                    break
        
        print(f"\n📱 Bootloader device #{i}")
        if device_info['type'] == 'mounted':
            print(f"   Already mounted at: {mount_point}")
        else:
            print(f"   Device: {device_path}")
            print(f"   Mounted at: {mount_point}")
        
        if usb_serial:
            print(f"   USB Serial: {usb_serial}")
            
        if bootloader_info:
            for key, value in bootloader_info.items():
                print(f"   {key}: {value}")
        
        # If we found a match, suggest it
        if matched_config:
            device_name = matched_config['name']
            device_side = matched_config.get('side', 'unknown')
            print(f"\n✨ Auto-detected: {device_name} ({device_side} side)")
            
            # Find appropriate firmware
            firmware_file = find_firmware_file(device_name, device_side, firmware_dir)
            if firmware_file:
                if require_confirmation:
                    confirm = input(f"Flash {os.path.basename(firmware_file)} to {device_name}? [Y/n]: ").strip().lower()
                    if confirm in ['', 'y', 'yes']:
                        flashable.append((mount_point, matched_config, firmware_file, needs_unmount))
                        print(f"✅ Will flash {os.path.basename(firmware_file)} to {device_name}")
                        continue
                    else:
                        print("Skipping auto-detected device")
                else:
                    flashable.append((mount_point, matched_config, firmware_file, needs_unmount))
                    print(f"✅ Will flash {os.path.basename(firmware_file)} to {device_name}")
                    continue
            else:
                print(f"❌ No firmware found for {device_name} ({device_side} side)")
        
        # List configured devices for user to choose from
        print(f"\nConfigured devices:")
        device_list = list(known_devices.items())
        for j, (serial, config) in enumerate(device_list, 1):
            side = config.get('side', 'unknown')
            print(f"  {j}. {config['name']} ({side} side)")
        
        print("  0. Skip this device")
        
        try:
            choice = input("Which device is this? (number): ").strip()
            if choice == '0':
                if needs_unmount:
                    unmount_device(mount_point)
                continue
                
            choice_idx = int(choice) - 1
            if 0 <= choice_idx < len(device_list):
                serial, config = device_list[choice_idx]
                device_name = config['name']
                device_side = config.get('side', 'unknown')
                
                # Find appropriate firmware
                firmware_file = find_firmware_file(device_name, device_side, firmware_dir)
                if firmware_file:
                    flashable.append((mount_point, config, firmware_file, needs_unmount))
                    print(f"✅ Will flash {os.path.basename(firmware_file)} to {device_name}")
                else:
                    print(f"❌ No firmware found for {device_name} ({device_side} side)")
                    if needs_unmount:
                        unmount_device(mount_point)
            else:
                print("Invalid choice, skipping device")
                if needs_unmount:
                    unmount_device(mount_point)
                
        except (ValueError, KeyboardInterrupt):
            print("Skipping device")
            if needs_unmount:
                unmount_device(mount_point)
            continue
    
    return flashable


def find_flashable_devices(known_devices, firmware_dir, require_confirmation=False):
    """
    Legacy wrapper for backwards compatibility. Uses scanning approach.
    """
    return scan_for_bootloaders(known_devices, firmware_dir, require_confirmation, 5)


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Auto-flash firmware to bootloader devices')
    parser.add_argument('--dry-run', '-n', action='store_true',
                        help='Show what would be flashed without actually flashing')
    parser.add_argument('--firmware-dir', '-f', 
                        default=str(Path(__file__).parent.parent / 'firmware'),
                        help='Directory containing firmware files')
    parser.add_argument('--confirm', '-c', action='store_true',
                        help='Ask for confirmation before flashing each device')
    parser.add_argument('--scan-duration', '-s', type=float, default=5.0,
                        help='How long to scan for bootloader devices in seconds (default: 5.0)')
    parser.add_argument('--no-scan', action='store_true',
                        help='Do not scan continuously, just check once')
    
    args = parser.parse_args()
    
    print("ZMK Auto Flash Tool")
    print("=" * 50)
    
    # Load device configuration
    known_devices = load_device_config()
    if not known_devices:
        print("No devices configured in ~/.config/zmk/devices.yaml")
        print("Run 'scripts/zmk-devices --add-new' to configure devices first.")
        return
    
    firmware_dir = Path(args.firmware_dir)
    if not firmware_dir.exists():
        print(f"Firmware directory not found: {firmware_dir}")
        print("Run 'just build <target>' to build firmware first.")
        return
    
    # Find devices that can be flashed
    scan_duration = 0 if args.no_scan else args.scan_duration
    flashable_devices = scan_for_bootloaders(known_devices, firmware_dir, args.confirm, scan_duration)
    
    if not flashable_devices:
        print("\nNo flashable devices found.")
        print("Make sure devices are in bootloader mode (double-tap reset button).")
        return
    
    print(f"\nFound {len(flashable_devices)} device(s) ready to flash")
    
    if args.dry_run:
        print("\n[DRY RUN] Would flash the following:")
        for item in flashable_devices:
            mount_point, config, firmware_file = item[0], item[1], item[2]
            print(f"  {config['name']}: {os.path.basename(firmware_file)} -> {mount_point}")
        return
    
    # Flash devices
    print(f"\nFlashing {len(flashable_devices)} device(s)...")
    
    success_count = 0
    for item in flashable_devices:
        mount_point, config, firmware_file = item[0], item[1], item[2]
        needs_unmount = item[3] if len(item) > 3 else False
        device_name = config['name']
        
        if flash_device(mount_point, firmware_file, device_name):
            success_count += 1
            # Brief pause to allow device to reset
            time.sleep(1)
        
        # Unmount if we mounted it temporarily
        if needs_unmount:
            print(f"Unmounting {mount_point}...")
            unmount_device(mount_point)
    
    print(f"\n🎉 Successfully flashed {success_count}/{len(flashable_devices)} device(s)")
    
    if success_count < len(flashable_devices):
        sys.exit(1)


if __name__ == "__main__":
    main()