// -*- mode: dts -*-
#define HOST_OS 1 // linux. impacts unicode entry. anything else?

#include <behaviors.dtsi>
#include <behaviors/unicode.dtsi> // Requires zmk-unicode module.
#include <behaviors/num_word.dtsi> // Requires auto-layer module.
#include <dt-bindings/zmk/keys.h>

#ifdef CONFIG_WIRELESS
  #include <dt-bindings/zmk/bt.h>
  #include <dt-bindings/zmk/outputs.h>
#endif

#define KEYS_L LT0 LT1 LT2 LT3 LT4 LT5     LM0 LM1 LM2 LM3 LM4 LM5     LB0 LB1 LB2 LB3 LB4 LB5 
#define KEYS_R RT0 RT1 RT2 RT3 RT4 RT5     RM0 RM1 RM2 RM3 RM4 RM5     RB0 RB1 RB2 RB3 RB4 RB5
#define THUMBS LH2 LH1 LH0     RH0 RH1 RH2




#include "zmk-helpers/helper.h"
#include "zmk-helpers/unicode-chars/greek.dtsi"
#include "zmk-helpers/unicode-chars/french.dtsi"
#include "zmk-helpers/unicode-chars/german.dtsi"
#include "elpekenin/behaviors.dtsi"

/*
I can't get this to work but it would be great to have it work like this:

ZMK_BASE_LAYER(Base,
//╭─────────────┬─────────────┬─────────────┬─────────────┬─────────────┬─────────────╮ ╭─────────────┬─────────────┬─────────────┬─────────────┬─────────────┬─────────────╮
    &kp H          &kp E         &kp L         &kp P         &kp M          &kp E     ,     &kp I         &kp M         &kp T         &kp R        &kp A         &kp P      ,
//├─────────────┼─────────────┼─────────────┼─────────────┼─────────────┼─────────────┤ ├─────────────┼─────────────┼─────────────┼─────────────┼─────────────┤─────────────┤
    &kp H          &kp E         &kp L         &kp P         &kp M          &kp E     ,     &kp I         &kp M         &kp T         &kp R        &kp A         &kp P      ,
//├─────────────┼─────────────┼─────────────┼─────────────┼─────────────┼─────────────┤ ├─────────────┼─────────────┼─────────────┼─────────────┼─────────────┤─────────────┤
    &kp H          &kp E         &kp L         &kp P         &kp M          &kp E     ,     &kp I         &kp M         &kp T         &kp R        &kp A         &kp P      ,
//╰─────────────┴─────────────┴─────────────┼─────────────┼─────────────┼─────────────┤ ├─────────────┼─────────────┼─────────────┼─────────────┴─────────────┴─────────────╯
                                               &kp X          &kp X       &kp X       ,     &kp X          &kp X       &kp X      ,
//                                          ╰─────────────┴─────────────┴─────────────╯ ╰─────────────┴─────────────┴─────────────╯
//                             ╭─────────────╮
                                   &kp U
// ╭────────────╮ ╭────────────┼─────────────┼─────────────╮
      &kp MUTE        &kp L        &kp MUTE      &kp R
// ╰────────────╯ ╰────────────┼─────────────┼─────────────╯
                                   &kp D
//                             ╰─────────────╯
)
*/


/*

TODO:

* super specific "smart" nav keys: shift into nav, hit an arrow key: arrows stay active until a non-arrow is pressed. same or page up/page down. or should they be the same?

* how to make comma and dot combos active while smart num is active, without deactivating it?

* timing issues:
	* typing bigrams at normal speed often erroneously activates the combo on those keys. example: "re" may produce open parenthesis instead of the letters r and e.
	* typing shift singlequote to get double quote often fails and results in single quote. (opposite hand mod and key)
	* typing at normal speed often places a space after the character before which it was intended. example: "this is" might come out as "thisi s"

* hrms should pass mod to combos, esp those defined with ZMK_COMBO_SIMPLE

* try finessing timings for tap/hold/doubletap to see if it can be made non-annoying

* make layer switch combos toggle between base and the other layer?

* how to specify bluetooth-related functionality

* how to illuminate the RGB LED for a specific key

* can i rearrange the layer definitions to remove the encoder and d-pad from their current positions and place them underneath? (it's confusing to have them in the middle)

key numbers

0  1  2  3  4  5          6       7  8  9 10 11 12
13 14 15 16 17 18      19 20 21   22 23 24 25 26 27
28 29 30 31 32 33   34    35      36 37 38 39 40 41
         42 43 44                 45 46 47


 0  1  2  3  4  5          6       7  8  9 10 11 12
    q  w  e  r  t                  y  u  i  o  p  '

13 14 15 16 17 18      19 20 21   22 23 24 25 26 27
    a  s  d  f  g                  h  j  k  l  ;  '

28 29 30 31 32 33   34    35      36 37 38 39 40 41
    z  x  c  v  b                  n  m  ,  .  /

         42 43 44                 45 46 47

*/


#include <dt-bindings/zmk/mouse.h>
#include <dt-bindings/zmk/rgb.h>

#include <input/processors.dtsi>

#define BASE 0
#define GAMING 1
#define ALT_ALPHA 2
#define CAPS_LAYER 3
#define NUMERIC 4
#define NAVIGATION 5
#define FN 6
#define EXTRA 7
#define RGB 8
#define SYSTEM 9
#define MODIFIER_LEFT_NAV 10
#define MODIFIER_RIGHT_NAV 11
#define BLUETOOTH 12
#define SUPERSCRIPT 13


// short versions for helping things line up
#define NUM NUMERIC
#define NAV NAVIGATION
#define LGUI_NAV_L MODIFIER_LEFT_NAV
#define RGUI_NAV_R MODIFIER_RIGHT_NAV
#define MENU K_APPLICATION


// which modifiers we want on which home row keys
#define L_M4 LGUI
#define L_M3 LALT
#define L_M2 LSHIFT
#define L_M1 LCTRL
//#define L_M0 N/A

//#define L_M0 N/A
#define R_M1 RCTRL
#define R_M2 RSHIFT
#define R_M3 RALT
#define R_M4 RGUI



#define HRM_TIMEOUT 400
#define TAP_TIMEOUT 50
#define TAP_DANCE_TAPPING 250  	/* 200 seemed difficult to achieve */
#define FAST_TAP 230		// at 200, the double tap actions do not reliably trigger
#define INTERRUPT_TAP 50        // very short window, for interrupting tap dance
#define LONG_PAUSE 500		// e.g. before certain combos. 800 is too long. so is 600
/*

   &mmv_input_listener {
       input-processors = <&zip_xy_scaler 2 1>;
   };

   &msc_input_listener {
       input-processors = <&zip_xy_scaler 2 1>;
   };

 */

#define ZMK_MOUSE_DEFAULT_MOVE_VAL 1200  // 600
#define ZMK_MOUSE_DEFAULT_SCRL_VAL 20    // 10

#define QUICK_TAP_MS 175

#define SMART_NUM &smart_num NUM 0
ZMK_HOLD_TAP(smart_num, bindings = <&mo>, <&num_dance>; flavor = "balanced";
             tapping-term-ms = <200>; quick-tap-ms = <QUICK_TAP_MS>;)
ZMK_TAP_DANCE(num_dance, bindings = <&num_word NUM>, <&sl NUM>;
              tapping-term-ms = <200>;)

ZMK_TAP_DANCE(caps_word_lock_dance, bindings = <&sk LSHIFT>, <&caps_word>, <&kp CAPS>;
              tapping-term-ms = <300>;)
ZMK_TAP_DANCE(smart_num_lock_dance, bindings = <&sl NUM>, <&num_word NUM>, <&rgb_tog_num>;
              tapping-term-ms = <300>;)


#define HRM_PRIOR_IDLE 80	// 100 caused false taps over holds, particularly with LCTRL. maybe this will be better. but note i seem to roll AR while normal typing which causes problems for accidental LGUI activation

#define MAKE_HRM(NAME, HOLD, TAP, TRIGGER_POS)                                    \
  ZMK_HOLD_TAP(NAME, bindings = <HOLD>, <TAP>; flavor = "balanced";               \
               tapping-term-ms = <200>; quick-tap-ms = <QUICK_TAP_MS>;            \
               require-prior-idle-ms = <HRM_PRIOR_IDLE>; hold-trigger-on-release; \
               hold-trigger-key-positions = <TRIGGER_POS>;)



MAKE_HRM(hml, &kp, &kp, KEYS_R THUMBS) // Left-hand HRMs.
MAKE_HRM(hmr, &kp, &kp, KEYS_L THUMBS) // Right-hand HRMs.



#include "build_info.dtsi"
//#include "tap-hold-layer.dtsi"

&lt {
    tapping-term-ms = <150>;
    quick-tap-ms = <150>;
    flavor = "tap-preferred";
};

&uc {
  default-mode = <UC_MODE_LINUX>;
};


/ {
  macros {
 #include "macros.dtsi"
      #include "layer-mod-macros.dtsi"
      #include "emoji.dtsi"
  };
};


#include "bt-modsel.dtsi"
#include "leader.dtsi"

ZMK_UNICODE_SINGLE(em_dash, N2, N0, N1, N4)

//BT_MODSEL(0)
//BT_MODSEL(1)
//BT_MODSEL(2)
//BT_MODSEL(3)
//BT_MODSEL(4)
//BT_MODSEL(5)

		


/ {
	behaviors {

#include "alphanumerics.dtsi"
#include "tap-hold-layer-behaviors.dtsi"
#include "modifier-tap-doubletap-behaviors.dtsi"
#include "arcane.dtsi"

ZMK_KEY_LAYER(SQT,NUM)
ZMK_KEY_LAYER(DQT,NUM)
ZMK_KEY_LAYER(ENTER, NAV)

// RGB control behaviors for delayed activation
rgb_on_behavior: rgb_on_behavior {
    compatible = "zmk,behavior-macro";
    #binding-cells = <0>;
    bindings = <&rgb_ug RGB_ON>;
};
        
rgb_off_behavior: rgb_off_behavior {
    compatible = "zmk,behavior-macro";
    #binding-cells = <0>;
    bindings = <&rgb_ug RGB_OFF>;
};
        
to_nav: to_nav {
    compatible = "zmk,behavior-macro";
    #binding-cells = <0>;
    wait-ms = <1000>;
    bindings = <&to NAV>, <&rgb_ug RGB_ON>, <&rgb_ug RGB_OFF>;
};


// for testing behavior-delayed, which does not currently work
delayed_rgb_on: delayed_rgb_on {
    compatible = "zmk,behavior-delayed";
    #binding-cells = <1>;  // delay in milliseconds
    bindings = <&rgb_on_behavior>;
    delay-ms = <1000>; // Default delay if not specified in binding
};
        
delayed_rgb_off: delayed_rgb_off {
    compatible = "zmk,behavior-delayed";
    #binding-cells = <1>;  // delay in milliseconds
    bindings = <&rgb_off_behavior>;
    delay-ms = <1000>;
};


comma_semicolon: comma_semicolon {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&kp COMMA>, <&kp SEMI>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};

dot_colon: dot_colon {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&kp DOT>, <&kp COLON>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};

dash_emdash: dash_emdash {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&kp MINUS>, <&em_dash>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};


fancy_bt_0: fancy_bt_0 {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&bt BT_SEL 0>, <&bt BT_DISC 0>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};		

fancy_bt_1: fancy_bt_1 {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&bt BT_SEL 1>, <&bt BT_DISC 1>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};		

fancy_bt_2: fancy_bt_2 {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&bt BT_SEL 2>, <&bt BT_DISC 2>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};		

fancy_bt_3: fancy_bt_3 {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&bt BT_SEL 3>, <&bt BT_DISC 3>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};		

fancy_bt_4: fancy_bt_4 {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&bt BT_SEL 4>, <&bt BT_DISC 4>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};		

fancy_bt_5: fancy_bt_5 {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&bt BT_SEL 5>, <&bt BT_DISC 5>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};		

fancy_bt_6: fancy_bt_6 {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&bt BT_SEL 6>, <&bt BT_DISC 6>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};		

// the morphed behavior seems to do nothing. have tried 20, 99, and 999 with MOVE_X and MOVE_Y
msc_up_variable: msc_up_variable {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&msc SCRL_UP>, <&msc MOVE_Y(20)>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};

msc_down_variable: msc_down_variable {
    compatible = "zmk,behavior-mod-morph";
    #binding-cells = <0>;
    bindings = <&msc SCRL_DOWN>, <&msc MOVE_Y(-20)>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
};

smart_nav_thumb: smart_nav_thumb {
    compatible = "zmk,behavior-hold-tap";
    #binding-cells = <2>;
    flavor = "hold-preferred";
    tapping-term-ms = <200>;
    quick-tap-ms = <175>;
    bindings = <&sl>, <&kp>;
};

arcane_nav_l: arcane_nav_l {
    compatible = "zmk,behavior-hold-tap";
    #binding-cells = <2>;
    flavor = "hold-preferred";
    tapping-term-ms = <200>;
    quick-tap-ms = <175>;
    bindings = <&sl>, <&arcane_left>;
};

arcane_nav_r: arcane_nav_r {
    compatible = "zmk,behavior-hold-tap";
    #binding-cells = <2>;
    flavor = "hold-preferred";
    tapping-term-ms = <200>;
    quick-tap-ms = <175>;
    bindings = <&sl>, <&arcane_right>;
};


		

	menu_smart_num: menu_smart_num {
	    compatible = "zmk,behavior-tap-dance";
	    #binding-cells = <0>;
	    tapping-term-ms = <300>; /* is this the time limit to invoke smart_num here? i swear i'm doing it faster than 250 but it seems not to activate often at that point */
	    bindings = <&kp MENU>, <&smart_num NUM 0>;
	};

	// hold LGUI, tap for space, double tap for tab
	// BUT using this may make spaces slooow so we'll switch to something else soon
        lgui_space_tab: lgui_space_tab {
            compatible = "zmk,behavior-tap-dance";
            #binding-cells = <0>;
            tapping-term-ms = <FAST_TAP>;
            bindings = <&ht_mod_kp LGUI SPACE>, <&kp TAB>;
        };

	// hold RGUI, tap for space, double tap for return
	// BUT using this may make spaces slooow so we'll switch to something else soon
        rgui_space_ret: rgui_space_ret {
            compatible = "zmk,behavior-tap-dance";
            #binding-cells = <0>;
            tapping-term-ms = <FAST_TAP>;
            bindings = <&ht_mod_kp RGUI SPACE>, <&kp RET>;
        };

        LTS: LTS {
            compatible = "zmk,behavior-hold-tap";
            #binding-cells = <2>;
            tapping-term-ms = <200>;
            quick-tap-ms = <175>;
            require-prior-idle-ms = <100>;
            flavor = "balanced";
            bindings = <&mo>, <&kp>;
        };

    };


    /* incomplete definition but should have basics for changing underglow while momentarily in a layer.
   ideally would save/restore preexisting underglow color.
   
    mo_rgb: mo_rgb {
        wait-ms = <0>;
 	tap-ms = <0>;
	bindings
	    = <&macro_press &mo 1>
	        , <&macro_tap &rgb_ug RGB_COLOR_HSB(128,100,100)>
		, <&macro_pause_for_release>
		, <&macro_release &mo 1>
		, <&macro_tap &rgb_ug RGB_COLOR_HSB(300,100,50)>
	;
    ;

*/

    /* Using tap_hold_layer_lgui directly in the keymap instead of a custom f_key behavior */

    rgb_encoder: rgb_encoder {
        compatible = "zmk,behavior-sensor-rotate";
        #sensor-binding-cells = <0>;
        bindings = <&rgb_ug RGB_BRI>, <&rgb_ug RGB_BRD>;
    };

    scroll_encoder: scroll_encoder {
        compatible = "zmk,behavior-sensor-rotate";
        #sensor-binding-cells = <0>;
        bindings = <&msc SCRL_DOWN>, <&msc SCRL_UP>;
        tap-ms = <30>;
    };


    combos {
        compatible = "zmk,combos";
 	#include "combos.dtsi"
    };


// ****************************************** BASE layer

#define BASE_LT &kp TAB  &kp Q  &kp W  &kp E  &kp R  &kp T
#define BASE_LM &key_layer_SQT_NUM  &tap_hold_layer_lgui LGUI_NAV_L A  &hml L_M3 S  &hml L_M2 D  &hml L_M1 F  &kp G
#define BASE_LB &trans &kp Z  &kp X  &kp C  &kp V  &kp B
#define BASE_LH &LTS EXTRA ESC  &smart_nav_thumb NAV TAB  &lgui_space_tab
#define BASE_LH_5 &trans &trans BASE_LH
#define BASE_LH_5 &trans &trans BASE_LH

/*
#define BASE_LZ &trans &trans &trans &trans &trans &trans
#define BASE_LT &trans &trans &trans &trans &trans &trans
#define BASE_LM &trans &trans &trans &trans &trans &trans
#define BASE_LB &trans &trans &trans &trans &trans &trans
#define BASE_LH &trans &trans &trans
*/


#define BASE_RZ &trans &trans &trans &trans &trans &trans
#define BASE_RT &kp Y    &kp U  &kp I  &kp O  &kp P  &kp BSPC
#define BASE_RM &kp H  &hmr R_M1 J  &hmr R_M2 K  &hmr R_M3 L  &tap_hold_layer_rgui RGUI_NAV_R SEMI  &key_layer_DQT_NUM
#define BASE_RB &kp N  &kp M  &kp COMMA  &kp DOT  &kp FSLH  &kp RET
#define BASE_RH &rgui_space_ret  &smart_nav_thumb NAV BSPC  &LTS FN RETURN
#define BASE_RH_5 &trans &trans BASE_RH

/*
#define BASE_RT &trans &trans &trans &trans &trans &trans
#define BASE_RM &trans &trans &trans &trans &trans &trans
#define BASE_RB &trans &trans &trans &trans &trans &trans
#define BASE_RH &trans &trans &trans
#define BASE_RH_5 &trans &trans BASE_RH
*/

// ****************************************** GAMING layer

#define GAMING_LZ &trans &trans &trans &trans &trans &trans
#define GAMING_LT &kp ESC  &kp Q  &kp W  &kp E  &kp R  &kp T		         
#define GAMING_LM &kp CAPS  &kp A  &kp S  &kp D  &kp F  &kp G
#define GAMING_LB &kp LSHIFT  &kp Z  &kp X  &kp C  &kp V  &kp B   
#define GAMING_LH &kp LCTRL  &kp TAB  &kp SPACE                
#define GAMING_LH_5 &trans &trans GAMING_LH

#define GAMING_RZ &trans &trans &trans &trans &trans &trans
#define GAMING_RT &kp Y  &kp U  &kp I  &kp O  &kp P  &kp BSPC
#define GAMING_RM &kp H  &kp J  &kp K  &kp L  &kp SEMI  &kp SQT
#define GAMING_RB &kp N  &kp M  &kp COMMA  &kp DOT  &kp FSLH  &kp RSHIFT
#define GAMING_RH &kp SPACE  &kp BSPC  &kp RETURN
#define GAMING_RH_5 &trans &trans GAMING_RH

// ******************************************  hierophant (alt_alpha) layer

#define HIEROPHANT_LZ &trans &trans &trans &trans &trans &trans
#define HIEROPHANT_LT &kp TAB  &kp F  &kp Z  &kp U  &kp Q  &kp BSPC
#define HIEROPHANT_LM &key_layer_SQT_NUM  &tap_hold_layer_lgui LGUI_NAV_L H  &hml L_M3 I  &hml L_M2 E  &hml L_M1 A  &kp P
#define HIEROPHANT_LB &kp BSLH  &comma_semicolon  &kp Y  &kp K  &kp O  &kp X
#define HIEROPHANT_LH &LTS EXTRA ESC  &arcane_nav_l NAV 0  &lgui_space_tab
#define HIEROPHANT_LH_5 &trans &trans HIEROPHANT_LH

#define HIEROPHANT_RZ &trans &trans &trans &trans &trans &trans
#define HIEROPHANT_RT &kp RETURN  &kp W  &kp D  &kp L  &kp B  &kp SEMI
#define HIEROPHANT_RM &kp G  &hmr R_M1 S  &hmr R_M2 T  &hmr R_M3 R  &tap_hold_layer_rgui RGUI_NAV_R N  &key_layer_DQT_NUM
#define HIEROPHANT_RB &kp V  &kp C  &kp M  &kp J  &dot_colon  &kp FSLH
#define HIEROPHANT_RH &rgui_space_ret  &arcane_nav_r NAV 0  &LTS FN RETURN
#define HIEROPHANT_RH_5 &trans &trans HIEROPHANT_RH


// ****************************************** CAPS layer

#define CAPS_LZ &trans &trans &trans &trans &trans &trans
#define CAPS_LT &caps_toggle &trans &trans &trans &trans &trans
#define CAPS_LM &trans &trans &trans &trans &trans &trans
#define CAPS_LB &trans &trans &trans &trans &trans &trans
#define CAPS_LH &trans &trans &trans
#define CAPS_LH_5 &trans &trans CAPS_LH

#define CAPS_RZ &trans &trans &trans &trans &trans &trans
#define CAPS_RT &trans &trans &trans &trans &trans &trans
#define CAPS_RM &trans &trans &trans &trans &trans &trans
#define CAPS_RB &trans &trans &trans &trans &trans &trans
#define CAPS_RH &trans &trans &trans
#define CAPS_RH_5 &trans &trans CAPS_RH


// ******************************************  NUMERIC layer

#define NUMERIC_LZ &trans &trans &trans &trans &trans &trans
#define NUMERIC_RZ &trans &trans &trans &trans &trans &trans

#define NUMERIC_LT &kp GRAVE  &kp EXCL  &kp AT        &kp HASH  &kp DOLLAR  &kp PERCENT
#define NUMERIC_RT &kp CARET  &kp AMPS  &kp ASTERISK  &kp LPAR  &kp RPAR    &kp EQUAL

#define NUMERIC_LM &kp N0  &hml L_M4 N1  &hml L_M3 N2  &hml L_M2 N3  &hml L_M1 N4  &kp N5
#define NUMERIC_RM &kp N6  &hmr R_M1 N7  &hmr R_M2 N8  &hmr R_M3 N9  &hmr R_M4 N0  &kp MINUS

#define NUMERIC_LB &cancel  &trans  &trans  &trans  &trans  &trans
#define NUMERIC_RB &trans  &trans  &trans  &trans  &trans  &cancel

#define NUMERIC_LH &trans  &trans  &trans                                                             
#define NUMERIC_RH &kp SPACE  &kp BACKSPACE  &kp PERIOD

#define NUMERIC_LH_5 &trans &trans NUMERIC_LH
#define NUMERIC_RH_5 &trans &trans NUMERIC_RH



// ******************************************  NAVIGATION layer

#define NAVIGATION_LZ &trans &trans &trans &trans &trans &trans
#define NAVIGATION_LT &trans  &kp PG_UP  &kp END  &kp UP_ARROW  &kp HOME  &msc_up_variable
#define NAVIGATION_LM &trans  &hml L_M4 PG_DN  &hml L_M3 LEFT_ARROW  &hml L_M2 DOWN_ARROW  &hml L_M1 RIGHT_ARROW  &msc_down_variable
#define NAVIGATION_LB &trans  &trans  &trans  &trans  &trans  &trans
#define NAVIGATION_LH &trans  &trans  &kp SPACE                                                          
#define NAVIGATION_LH_5 &trans &trans NAVIGATION_LH

#define NAVIGATION_RZ &trans &trans &trans &trans &trans &trans
#define NAVIGATION_RT &msc_up_variable  &kp HOME  &kp UP_ARROW  &kp END  &kp PG_UP  &trans
#define NAVIGATION_RM &msc_down_variable  &hmr R_M1 LEFT_ARROW  &hmr R_M2 DOWN_ARROW  &hmr R_M3 RIGHT_ARROW  &hmr R_M4 PG_DN  &trans
#define NAVIGATION_RB &mkp MB2  &mkp MB3  &mkp MB4  &mkp MB5  &trans  &trans
#define NAVIGATION_RH &kp SPACE  &trans  &trans
#define NAVIGATION_RH_5 &trans &trans NAVIGATION_RH



// ******************************************  FUNCTION layer

#define FUNCTION_LZ &trans &trans &trans &trans &trans &trans
#define FUNCTION_RZ &trans &trans &trans &trans &trans &trans

#define FUNCTION_LT &kp F1  &kp F2  &kp F3  &kp F4  &kp F5  &kp F6
#define FUNCTION_RT &kp F7  &kp F8  &kp F9  &kp F10  &kp F11  &kp F12

#define FUNCTION_LM &kp F13  &hml L_M4 F14  &hml L_M3 F15  &hml L_M2 F16  &hml L_M1 F17  &kp F18
#define FUNCTION_RM &kp F19  &hmr R_M1 F20  &hmr R_M2 F21  &hmr R_M3 F22  &hmr R_M4 F23  &kp F24

#define FUNCTION_LB &trans  &sys_reset  &trans  &bootloader  &trans  &mkp MB5 
#define FUNCTION_RB &trans  &trans  &bootloader  &sys_reset  &kp SCROLLLOCK  &kp PAUSE_BREAK

#define FUNCTION_LH &trans &trans &build_time
#define FUNCTION_RH &build_time  &trans  &trans

#define FUNCTION_LH_5 &trans &trans FUNCTION_LH
#define FUNCTION_RH_5 &trans &trans FUNCTION_RH

// ******************************************  EXTRA layer

#define EXTRA_LZ &trans &trans &trans &trans &trans &trans
#define EXTRA_LT &smart_w &trans &at_wgyl_org &trans &trans &trans
#define EXTRA_LM &trans &trans &trans &trans &trans &kp DELETE
#define EXTRA_LB &dash_emdash &trans &trans &trans &trans &trans
#define EXTRA_LH                      &trans &oneshot_or_to_NAVIGATION &trans
#define EXTRA_LH_5 &trans &trans EXTRA_LH


#define EXTRA_RZ &trans &trans &trans &trans &trans &trans
#define EXTRA_RT &trans &trans &trans &trans &phone_alt &trans
#define EXTRA_RM &kp INSERT &trans &trans &trans &trans &trans
#define EXTRA_RB &trans &trans &trans &trans &trans &key_repeat
#define EXTRA_RH   		  &trans &oneshot_or_to_NAVIGATION &trans
#define EXTRA_RH_5 &trans &trans EXTRA_RH


// ******************************************  RGB layer

#define RGB_LZ &trans &trans &trans &trans &trans &trans
#define RGB_RZ &trans &trans &trans &trans &trans &trans

#define RGB_LT &trans  &trans  &trans  &trans  &trans  &trans
#define RGB_RT &rgb_ug RGB_HUI  &rgb_ug RGB_SAI  &trans  &trans  &rgb_ug RGB_COLOR_HSB(0,100,100)    &rgb_ug RGB_COLOR_HSB(275,100,100)

#define RGB_LM &trans  &trans  &trans  &trans  &trans  &trans
#define RGB_RM &rgb_ug RGB_HUD  &rgb_ug RGB_SAD  &trans  &trans  &rgb_ug RGB_COLOR_HSB(90,100,100)   &rgb_ug RGB_COLOR_HSB(186,100,100)

#define RGB_LB &trans &trans &trans &trans &trans &trans
#define RGB_RB &trans &trans &trans &trans &rgb_ug RGB_COLOR_HSB(270,100,100) &rgb_ug RGB_COLOR_HSB(317,100,100)

#define RGB_LH &trans &trans &trans
#define RGB_RH &trans &trans &trans 

#define RGB_LH_5 &trans &trans RGB_LH
#define RGB_RH_5 &trans &trans RGB_RH



// ******************************************  SYSTEM layer

#define SYSTEM_LZ &trans &trans &trans &trans &trans &trans

#define SYSTEM_LT &bt BT_CLR    &bt BT_CLR_ALL  &trans        &trans        &trans        &trans

#define SYSTEM_LM &trans &trans &trans &trans &trans &trans
//#define SYSTEM_LM &bt BT_SEL 0  &hml L_M4 &bt BT_SEL 1  &hml L_M3 &bt BT_SEL 2  &hml L_M2 &bt BT_SEL 3  &hml L_M1 &bt BT_SEL 4 &bt BT_SEL 5


#define SYSTEM_LB &trans        &trans          &trans        &trans &trans &rgb_ug RGB_EFF
#define SYSTEM_LH &trans &trans &trans
#define SYSTEM_LH_5 &trans &trans SYSTEM_LH

#define SYSTEM_RZ &trans &trans &trans &trans &trans &trans
#define SYSTEM_RT &fancy_bt_0 &fancy_bt_1 &fancy_bt_2 &fancy_bt_3 &fancy_bt_4 &fancy_bt_5
#define SYSTEM_RM &trans &trans &trans &trans &trans &trans
#define SYSTEM_RB &rgb_ug RGB_EFR  &rgb_ug RGB_SPI  &rgb_ug RGB_BRI  &rgb_ug RGB_BRD  &kp END   &kp PG_DN
#define SYSTEM_RH &trans &trans &trans
#define SYSTEM_RH_5 &trans &trans SYSTEM_RH


// ******************************************  LGUI+NAV layer

#define LGN_LZ &trans &trans &trans &trans &trans &trans
#define LGN_RZ &trans &trans &trans &trans &trans &trans

#define LGN_LT &kp LG(TAB)    &kp LG(Q)  &kp LG(W)        &kp LG(E)        &kp LG(R)     &kp LG(T)
#define LGN_RT &msc LG(SCRL_UP)    &kp LG(HOME)        &kp LG(UP_ARROW)    &kp LG(END)          &kp LG(PG_UP)  &kp LG(BSPC)

#define LGN_LM &trans  &trans  &hml L_M3 LG(S)  &hml L_M2 LG(D)  &hml L_M1(F)  &kp LG(G)
#define LGN_RM &msc LG(SCRL_DOWN)  &kp LG(LEFT_ARROW)  &kp LG(DOWN_ARROW)  &kp LG(RIGHT_ARROW)  &kp LG(PG_DN)  &kp LG(SQT)

#define LGN_LB &kp LG(LCTRL)  &kp LG(Z)  &kp LG(X)        &kp LG(C)        &kp LG(V)     &kp LG(B)
#define LGN_RB &kp LG(N)           &kp LG(M)           &kp LG(COMMA)       &kp LG(DOT)          &kp LG(FSLH)   &kp LG(RET)

#define LGN_LH &kp LG(ESC)  &kp LG(TAB)  &to BASE
#define LGN_RH &to BASE  &kp LG(BSPC)  &kp LG(RET)

#define LGN_LH_5 &trans &trans LGN_LH
#define LGN_RH_5 &trans &trans LGN_RH


// ******************************************  RGUI+NAV layer

#define RGN_LZ &trans &trans &trans &trans &trans &trans
#define RGN_RZ &trans &trans &trans &trans &trans &trans

#define RGN_LT &kp RG(ESC)   &kp RG(PG_UP)  &kp RG(DELETE)      &kp RG(UP_ARROW)    &kp RG(HOME)         &msc RG(SCRL_UP)
#define RGN_RT &kp RG(Y)  &kp RG(U)     &kp RG(I)        &kp RG(O)        &kp RG(P)     &kp RG(BSPC)

#define RGN_LM &trans        &kp RG(PG_DN)  &kp RG(LEFT_ARROW)  &kp RG(DOWN_ARROW)  &kp RG(RIGHT_ARROW)  &msc RG(SCRL_DOWN)
#define RGN_RM &kp RG(H)  &hmr R_M1(J)  &hmr R_M2 RG(K)  &hmr R_M3 RG(L)  &trans        &kp RG(SQT)

#define RGN_LB &kp RG(LCTRL) &kp RG(Z)      &kp RG(X)           &kp RG(C)	     &kp RG(V)  	  &kp RG(B)
#define RGN_RB &kp RG(N)  &kp RG(M)     &kp RG(COMMA)    &kp RG(DOT)      &kp RG(FSLH)  &kp RG(RET)

#define RGN_LH &kp LG(ESC)         &kp LG(TAB)          &to BASE
#define RGN_RH &to BASE   &kp LG(BSPC)  &kp LG(RET)

#define RGN_LH_5 &trans &trans RGN_LH
#define RGN_RH_5 &trans &trans RGN_RH


// ******************************************  BLUETOOTH layer

#define BLUETOOTH_LZ &trans &trans &trans &trans &trans &trans

#define BLUETOOTH_LT &bt BT_SEL 0  &bt BT_SEL 1   &bt BT_SEL 2   &bt BT_SEL 3   &bt BT_SEL 4   &bt BT_SEL 5
#define BLUETOOTH_LM &bt BT_DISC 0 &bt BT_DISC 1  &bt BT_DISC 2  &bt BT_DISC 3  &bt BT_DISC 4  &bt BT_DISC 5
#define BLUETOOTH_LB &bt BT_CLR &trans &trans &trans &trans &trans
//#define BLUETOOTH_LB &bt BT_CLR 0  &bt BT_CLR 1   &bt BT_CLR 2   &bt BT_CLR 3   &bt BT_CLR 4   &bt BT_CLR 5

#define BLUETOOTH_LH &trans &trans &trans
#define BLUETOOTH_LH_5 &trans &trans BLUETOOTH_LH

#define BLUETOOTH_RZ &trans &trans &trans &trans &trans &trans
#define BLUETOOTH_RT &trans &trans &trans &trans &trans &trans
#define BLUETOOTH_RM &trans &trans &trans &trans &trans &trans
#define BLUETOOTH_RB &trans &trans &trans &trans &trans &trans
#define BLUETOOTH_RH &trans &trans &trans
#define BLUETOOTH_RH_5 &trans &trans BLUETOOTH_RH



/*

// ******************************************  EMPTY layer

#define _LZ &trans &trans &trans &trans &trans &trans
#define _RZ &trans &trans &trans &trans &trans &trans

#define _LT &trans &trans &trans &trans &trans &trans
#define _RT &trans &trans &trans &trans &trans &trans

#define _LM &trans &trans &trans &trans &trans &trans
#define _RM &trans &trans &trans &trans &trans &trans

#define _LB &trans &trans &trans &trans &trans &trans
#define _RB &trans &trans &trans &trans &trans &trans

#define _LH &trans &trans &trans
#define _RH &trans &trans &trans

#define _LH_5 &trans &trans _LH
#define _RH_5 &trans &trans _RH

*/

// ****************************************** SUPERSCRIPT layer

#define SUPERSCRIPT_LZ &trans &trans &trans &trans &trans &trans
#define SUPERSCRIPT_RZ &trans &trans &trans &trans &trans &trans

#define SUPERSCRIPT_LT &trans &trans &trans &trans &trans &trans
#define SUPERSCRIPT_RT &trans &trans &trans &trans &trans &trans

#define SUPERSCRIPT_LM &trans &trans &trans &trans &trans &trans
#define SUPERSCRIPT_RM &trans &trans &trans &trans &trans &trans

#define SUPERSCRIPT_LB &trans &trans &trans &trans &trans &trans
#define SUPERSCRIPT_RB &trans &trans &trans &trans &trans &trans

#define SUPERSCRIPT_LH &trans &trans &trans
#define SUPERSCRIPT_RH &trans &trans &trans

#define SUPERSCRIPT_LH_5 &trans &trans _LH
#define SUPERSCRIPT_RH_5 &trans &trans _RH

}; // root node
